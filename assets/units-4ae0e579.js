var G=Object.defineProperty;var H=(n,t,i)=>t in n?G(n,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):n[t]=i;var M=(n,t,i)=>(H(n,typeof t!="symbol"?t+"":t,i),i),V=(n,t,i)=>{if(!t.has(n))throw TypeError("Cannot "+i)};var s=(n,t,i)=>(V(n,t,"read from private field"),i?i.call(n):t.get(n)),g=(n,t,i)=>{if(t.has(n))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(n):t.set(n,i)},C=(n,t,i,e)=>(V(n,t,"write to private field"),e?e.call(n,i):t.set(n,i),i);var l=(n,t,i)=>(V(n,t,"access private method"),i);import{aY as J,aw as K,an as p,aA as v,aS as q,aR as Q,b3 as W,a5 as X,b$ as z,c8 as Y}from"./index-934d48f6.js";const O=BigInt(-1),d=BigInt(0),N=BigInt(1),tt=BigInt(5),I={};let F="0000";for(;F.length<80;)F+=F;function x(n){let t=F;for(;t.length<n;)t+=t;return BigInt("1"+t.substring(0,n))}function y(n,t,i){const e=BigInt(t.width);if(t.signed){const r=N<<e-N;v(i==null||n>=-r&&n<r,"overflow","NUMERIC_FAULT",{operation:i,fault:"overflow",value:n}),n>d?n=z(Y(n,e),e):n=-z(Y(-n,e),e)}else{const r=N<<e;v(i==null||n>=0&&n<r,"overflow","NUMERIC_FAULT",{operation:i,fault:"overflow",value:n}),n=(n%r+r)%r&r-N}return n}function _(n){typeof n=="number"&&(n=`fixed128x${n}`);let t=!0,i=128,e=18;if(typeof n=="string"){if(n!=="fixed")if(n==="ufixed")t=!1;else{const a=n.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);p(a,"invalid fixed format","format",n),t=a[1]!=="u",i=parseInt(a[2]),e=parseInt(a[3])}}else if(n){const a=n,u=(f,B,D)=>a[f]==null?D:(p(typeof a[f]===B,"invalid fixed format ("+f+" not "+B+")","format."+f,a[f]),a[f]);t=u("signed","boolean",t),i=u("width","number",i),e=u("decimals","number",e)}p(i%8===0,"invalid FixedNumber width (not byte aligned)","format.width",i),p(e<=80,"invalid FixedNumber decimals (too large)","format.decimals",e);const r=(t?"":"u")+"fixed"+String(i)+"x"+String(e);return{signed:t,width:i,decimals:e,name:r}}function it(n,t){let i="";n<d&&(i="-",n*=O);let e=n.toString();if(t===0)return i+e;for(;e.length<=t;)e=F+e;const r=e.length-t;for(e=e.substring(0,r)+"."+e.substring(r);e[0]==="0"&&e[1]!==".";)e=e.substring(1);for(;e[e.length-1]==="0"&&e[e.length-2]!==".";)e=e.substring(0,e.length-1);return i+e}var m,o,h,b,S,c,w,A,$,E,P,T,Z,R,k;const U=class U{constructor(t,i,e){g(this,b);g(this,c);g(this,A);g(this,E);g(this,T);g(this,R);M(this,"format");g(this,m,void 0);g(this,o,void 0);g(this,h,void 0);M(this,"_value");J(t,I,"FixedNumber"),C(this,o,i),C(this,m,e);const r=it(i,e.decimals);K(this,{format:e.name,_value:r}),C(this,h,x(e.decimals))}get signed(){return s(this,m).signed}get width(){return s(this,m).width}get decimals(){return s(this,m).decimals}get value(){return s(this,o)}addUnsafe(t){return l(this,A,$).call(this,t)}add(t){return l(this,A,$).call(this,t,"add")}subUnsafe(t){return l(this,E,P).call(this,t)}sub(t){return l(this,E,P).call(this,t,"sub")}mulUnsafe(t){return l(this,T,Z).call(this,t)}mul(t){return l(this,T,Z).call(this,t,"mul")}mulSignal(t){l(this,b,S).call(this,t);const i=s(this,o)*s(t,o);return v(i%s(this,h)===d,"precision lost during signalling mul","NUMERIC_FAULT",{operation:"mulSignal",fault:"underflow",value:this}),l(this,c,w).call(this,i/s(this,h),"mulSignal")}divUnsafe(t){return l(this,R,k).call(this,t)}div(t){return l(this,R,k).call(this,t,"div")}divSignal(t){v(s(t,o)!==d,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),l(this,b,S).call(this,t);const i=s(this,o)*s(this,h);return v(i%s(t,o)===d,"precision lost during signalling div","NUMERIC_FAULT",{operation:"divSignal",fault:"underflow",value:this}),l(this,c,w).call(this,i/s(t,o),"divSignal")}cmp(t){let i=this.value,e=t.value;const r=this.decimals-t.decimals;return r>0?e*=x(r):r<0&&(i*=x(-r)),i<e?-1:i>e?1:0}eq(t){return this.cmp(t)===0}lt(t){return this.cmp(t)<0}lte(t){return this.cmp(t)<=0}gt(t){return this.cmp(t)>0}gte(t){return this.cmp(t)>=0}floor(){let t=s(this,o);return s(this,o)<d&&(t-=s(this,h)-N),t=s(this,o)/s(this,h)*s(this,h),l(this,c,w).call(this,t,"floor")}ceiling(){let t=s(this,o);return s(this,o)>d&&(t+=s(this,h)-N),t=s(this,o)/s(this,h)*s(this,h),l(this,c,w).call(this,t,"ceiling")}round(t){if(t==null&&(t=0),t>=this.decimals)return this;const i=this.decimals-t,e=tt*x(i-1);let r=this.value+e;const a=x(i);return r=r/a*a,y(r,s(this,m),"round"),new U(I,r,s(this,m))}isZero(){return s(this,o)===d}isNegative(){return s(this,o)<d}toString(){return this._value}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(t){return U.fromString(this.toString(),t)}static fromValue(t,i,e){const r=i==null?0:q(i),a=_(e);let u=Q(t,"value");const f=r-a.decimals;if(f>0){const B=x(f);v(u%B===d,"value loses precision for format","NUMERIC_FAULT",{operation:"fromValue",fault:"underflow",value:t}),u/=B}else f<0&&(u*=x(-f));return y(u,a,"fromValue"),new U(I,u,a)}static fromString(t,i){const e=t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);p(e&&e[2].length+e[3].length>0,"invalid FixedNumber string value","value",t);const r=_(i);let a=e[2]||"0",u=e[3]||"";for(;u.length<r.decimals;)u+=F;v(u.substring(r.decimals).match(/^0*$/),"too many decimals for format","NUMERIC_FAULT",{operation:"fromString",fault:"underflow",value:t}),u=u.substring(0,r.decimals);const f=BigInt(e[1]+a+u);return y(f,r,"fromString"),new U(I,f,r)}static fromBytes(t,i){let e=W(X(t,"value"));const r=_(i);return r.signed&&(e=z(e,r.width)),y(e,r,"fromBytes"),new U(I,e,r)}};m=new WeakMap,o=new WeakMap,h=new WeakMap,b=new WeakSet,S=function(t){p(this.format===t.format,"incompatible format; use fixedNumber.toFormat","other",t)},c=new WeakSet,w=function(t,i){return t=y(t,s(this,m),i),new U(I,t,s(this,m))},A=new WeakSet,$=function(t,i){return l(this,b,S).call(this,t),l(this,c,w).call(this,s(this,o)+s(t,o),i)},E=new WeakSet,P=function(t,i){return l(this,b,S).call(this,t),l(this,c,w).call(this,s(this,o)-s(t,o),i)},T=new WeakSet,Z=function(t,i){return l(this,b,S).call(this,t),l(this,c,w).call(this,s(this,o)*s(t,o)/s(this,h),i)},R=new WeakSet,k=function(t,i){return v(s(t,o)!==d,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),l(this,b,S).call(this,t),l(this,c,w).call(this,s(this,o)*s(this,h)/s(t,o),i)};let L=U;const j=["wei","kwei","mwei","gwei","szabo","finney","ether"];function et(n,t){let i=18;if(typeof t=="string"){const e=j.indexOf(t);p(e>=0,"invalid unit","unit",t),i=3*e}else t!=null&&(i=q(t,"unit"));return L.fromValue(n,i,{decimals:i,width:512}).toString()}function nt(n,t){p(typeof n=="string","value must be a string","value",n);let i=18;if(typeof t=="string"){const e=j.indexOf(t);p(e>=0,"invalid unit","unit",t),i=3*e}else t!=null&&(i=q(t,"unit"));return L.fromString(n,{decimals:i,width:512}).value}function ot(n){return et(n,18)}function lt(n){return nt(n,18)}export{L as F,nt as a,ot as b,et as f,lt as p};
